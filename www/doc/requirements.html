<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <title>Requirements Template</title>

    <link rel="stylesheet" type="text/css"
    href="/style/documentation.css">

    <link rel="home" href="/doc/">
    <link rel="up" href="index.html">
    <link rel="index" href="index.html">
    <link rel="previous" href="index.html">
    <link rel="next" href="design.html">
  </head>
<body>

<h2><a name="template"></a>System/Application Requirements Template</h2>

<p>By <a href="mailto:youremail@arsdigita.com">You</a></p>


<h3><a name="introduction"></a>Introduction</h3>

<div class="template"><p>Briefly explain to the reader what this
document is for, whether it records the requirements for a new system,
a client application, a toolkit subsystem, etc. Remember your
audience: fellow programmers, AND interested non-technical parties
such as potential clients, who may all want to see how rigorous our
engineering process is. Here and everywhere, write clearly and
precisely; for requirements documentation, write at a level that any
intelligent layperson can understand.</p>
</div>


<h3><a name="vision"></a>Vision Statement</h3>

<div class="template"><p>Very broadly, describe how the system meets a
need of a business, group, the OpenACS as a whole, etc.  Make sure
that technical and non-technical readers alike would understand what
the system would do and why it's useful.  Whenever applicable, you
should explicitly state what the business value of the system is. </p>
</div>


<h3><a name="overview"></a>System/Application Overview</h3>

<div class="template"><p>Discuss the high-level breakdown of the
components that make up the system.  You can go by functional areas,
by the main transactions the system allows, etc. </p>

<p>You should also state the context and dependencies of the system
here, e.g. if it's an application-level package for OpenACS 4, briefly
describe how it uses kernel services, like permissions or
subsites. </p></div>

<h3><a name="cases"></a>Use-cases and User-scenarios</h3>

<div class="template"><p>Determine the types or classes of users who
would use the system, and what their experience would be like at a
high-level.  Sketch what their experience would be like and what
actions they would take, and how the system would support them.</p>
</div>


<h3><a name="competitive-analysis"></a>CompetitiveAnalysis (opt)</h3>

<div class="template"><p>Describe other systems or services that are
comparable to what you're building.  If applicable, say why your
implementation will be superior, where it will match the competition,
and where/why it will lack existing best-of-breed capabilities.  This
section is also in the Design doc, so write about it where you deem
most appropriate.</p>
</div>

<h3><a name="links"></a>Related Links</h3>

<div class="template">
<p>Include all pertinent links to supporting and related material,
      such as: </p>
<ul>
  <li><p> System/Package &quot;coversheet&quot; - where all documentation for this software is linked off of</p></li>
  <li><p> Design document</p></li>
  <li><p> Developer's guide</p></li>
  <li><p> User's guide</p></li>
  <li><p> Other-cool-system-related-to-this-one document</p></li>
  <li><p> Test plan </p></li>
  <li><p> Competitive system(s)</p></li>
</ul>
</div>

<h3><a name="requirements"></a>Requirements</h3>

<div class="template"><p>The main course of the document,
requirements. Break up the requirements sections (A, B, C, etc.) as
needed.  Within each section, create a list denominated with unique
identifiers that reflect any functional hierarchy present,
e.g. 20.5.13. - for the first number, leave generous gaps on the first
writing of requirements (e.g. 1, 10, 20, 30, 40, etc.) because you'll
want to leave room for any missing key requirements that may
arise.</p>

<ul>
  <li><p><strong>10.0 A Common Solution</strong></p>
      <p>Programmers and designers should only have to learn a single
      system that serves as a UI substrate for all the functionally
      specific modules in the toolkit.</p>

      <blockquote class="blockquote">
        <p><span class="strong"><i>10.0.1</i></span></p>
	<p>The system should not make any assumptions about how pages
	should look or function.</p>

	<p><span class="strong"><i>10.0.5</i></span></p>
	<p>Publishers should be able to change the default
	presentation of any module using a single methodology with
	minimal exposure to code.</p>
      </blockquote>
  </li>
</ul>

<p>For guidelines writing requirements, take a <a
href="http://www.arsdigita.com/ad-sepg/process/requirements-quality.html"
target="_top">look at the quality standards</a>, along with a good
example, such as <a href="apm-requirements.html">OpenACS 4 Package
Manager Requirements</a>.</p>

<p>Besides writing requirements in natural language, consider using
the following techniques as needed:</p>

<ul>
  <li><p>Pseudocode - a quasi programming language, combining the
  informality of natural language with the strict syntax and control
  structures of a programming language.</p></li>

  <li><p>Finite State Machines - a hypothetical machine that can be in
  only one of a given number of states at any specific time.  Useful
  to model situations that are rigidly deterministic, that is, any set
  of inputs mathematically determines the system outputs. </p></li>

  <li><p>Decision Trees and Decision Tables - similar to FSMs, but
  better suited to handle combinations of inputs.  </p></li>

  <li><p>Flowcharts - easy to draw and understand, suited for event
  and decision driven systems.  UML is the industry standard
  here.</p></li>

  <li><p>Entity-Relationship diagrams - a necessary part of Design
  documents, sometimes a high-level ER diagram is useful for
  requirements as well.</p></li>
</ul>
</div>


<h3><a name="implementation"></a>Optional: Implementation Notes</h3>

<div class="template"><p>Although in theory coding comes after design,
which comes after requirements, we do not, and perhaps should not,
always follow such a rigid process (a.k.a. the waterfall lifecyle).
Often, there is a pre-existing system or prototype first, and thus you
may want to write some thoughts on implementation, for aiding and
guiding yourself or other programmers. </p>
</div>

<h3><a name="history"></a>Revision History</h3>

<table>
<colgroup><col><col><col><col></colgroup>
<thead><tr>
  <th>Document Revision #</th>
  <th>Action Taken, Notes</th>
  <th>When?</th>
  <th>By Whom?</th>
</tr></thead>
<tbody>
</tbody>
</table>

<p>($Id$)</p>

</body>
</html>
